<!DOCTYPE html>
<html lang="en">
<head>

    <title>PLARA Server</title>

    <style>
        body { font-family: sans-serif; padding: 1rem; }
        h1 { text-decoration: underline}
        summary { margin-top: 2rem; font-size: 1.5rem; font-weight: bold; }
        pre { background: #eee; padding: 1rem; max-height: 500px; overflow-y: auto; }
        button { margin: 10px; padding: 0.5rem 1rem; cursor: pointer; }
        input { width: 350px; padding: 0.5rem; }
        .connection-control { margin-bottom: 1rem; }
        label {font-weight: bold; }
    </style>
    <script>
        class Queue {
            constructor(limit = 10) {
                this.limit = limit;
                this.items = [];
            }

            enqueue(item) {
                // Add to queue
                this.items.unshift(item);

                // Keep only the last 'limit' items
                if (this.items.length > this.limit) {
                    this.items.pop(); // remove oldest
                }
            }

            reset(){
                this.items = [];
            }

            getItems() {
                return [...this.items];
            }
        }
    </script>
</head>
<body>
    <h1>Braude Project 2025 - PLARA</h1>
    <h4>Created by Shlomi Fridman and Shahar Berenson</h4>

<!--    <h2>Connection Status</h2>-->
    <div class="connection-control">
        <label for="wsAddress">WebSocket URI:</label>
        <input id="wsAddress" type="text" value="wss://braudeproject2025server.onrender.com/" placeholder="Enter WebSocket URL" />
        <button id="connectBtn">Connect</button>
        <br>
        <button id="toggleBtn">Switch to localhost</button>
        <button id="openSimBtn">Open Simulator</button>
    </div>
    <pre id="connStatusPre">Waiting for status...</pre>


    <details open>
        <summary>Current System Status</summary>
        <pre id="currStatusPre">Waiting for message...</pre>
    </details>

    <details open>
        <summary>Log Messages <button id="clearLogBtn">Clear</button></summary>
        <pre id="LogPre">Waiting for messages...</pre>
    </details>

    <details>
        <summary>Mqtt Messages <button id="clearMqttBtn">Clear</button></summary>
        <pre id="mqttPre">Waiting for messages...</pre>
    </details>

    <details>
        <summary>System Status Messages <button id="clearStatusBtn">Clear</button></summary>
        <pre id="statusPre">Waiting for messages...</pre>
    </details>

    <script>
        // Connect to your WebSocket server
        const REMOTE_URL = 'wss://braudeproject2025server.onrender.com/';
        const LOCAL_URL = 'ws://localhost:5000/';

        const connStatusPre = document.getElementById('connStatusPre');
        const logPre = document.getElementById('LogPre');
        const mqttPre = document.getElementById('mqttPre');
        const statusPre = document.getElementById('statusPre');
        const currStatusPre = document.getElementById('currStatusPre');

        const toggleBtn = document.getElementById('toggleBtn');
        const connectBtn = document.getElementById('connectBtn');
        const openSimBtn = document.getElementById('openSimBtn');

        const clearLogBtn = document.getElementById('clearLogBtn');
        const clearMqttBtn = document.getElementById('clearMqttBtn');
        const clearStatusBtn = document.getElementById('clearStatusBtn');

        const wsAddressInput = document.getElementById('wsAddress');



        const maxDisplayedMessages = 300;
        const mqttQueue = new Queue(maxDisplayedMessages);
        const statusQueue = new Queue(maxDisplayedMessages);
        const logQueue = new Queue(maxDisplayedMessages);

        let currentUrl = REMOTE_URL;
        let ws;

        // Auto-connect to default URL
        clearPre = (pre, queue = null) => {

            if (queue) {
                queue.reset();
            }
            pre.textContent = 'Waiting for messages...';
        }
        connectWebSocket = (url) => {

            if (ws) ws.close(1000, "Manual disconnect");
            connStatusPre.textContent = 'Connecting to ' + url + ' ...';

            ws = new WebSocket(url);
            ws.onopen = () => {

                console.log('Connection opened (' + ws.url + ')');
                connStatusPre.textContent = 'Connected to ' + url;
                ws.send("system_reset");
                ws.send("system_status");
                ws.send("log");
                ws.send("mqtt");

                currStatusPre.textContent = 'Waiting for messages...';
                clearLogBtn.click();
                clearMqttBtn.click();
                clearStatusBtn.click();
            };
            ws.onmessage = (event) => {

                // console.log('Message from server:', event.data);
                let data = event.data;
                try { data = JSON.parse(data); } catch {}
                if (data.topic === 'system_status'){
                    const formattedMessage = { ...data.message };
                    // if (formattedMessage.timestamp) {
                    //     formattedMessage.timestamp = new Date(formattedMessage.timestamp)
                    //         .toLocaleString('en-US', { weekday:'long', year:'numeric', month:'short', day:'numeric', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false, timeZone: 'UTC' });
                    // }
                    currStatusPre.textContent = JSON.stringify(formattedMessage, null, 2);
                    statusQueue.enqueue(formattedMessage);
                    prependMessage(statusPre, statusQueue);
                }
                else if (data.topic === 'mqtt'){
                    mqttQueue.enqueue(data.message)
                    prependMessage(mqttPre, mqttQueue);
                }
                else if (data.topic === 'log'){
                    logQueue.enqueue(data.message)
                    prependMessage(logPre, logQueue);
                }
            };
            ws.onerror = (err) => {

                console.error('WebSocket error:', err);
                connStatusPre.textContent = 'Connection error to ' + currentUrl;
            };
        }
        prependMessage = (pre, queue) => {

            const items = queue.getItems();
            const text = items.map(tmp => JSON.stringify(tmp, null, 2)).join('\n---------------------------------------\n');
            if (pre.textContent === 'Waiting for messages...') pre.textContent = '';
            pre.textContent = text;
        }
        openSimBtn.addEventListener('click', () => {
            window.open('/sim', '_blank');
        })

        toggleBtn.addEventListener('click', () => {
            console.error('WebSocket trying to disconnected');
            ws.close(1000, "Manual disconnect")

            if (currentUrl === REMOTE_URL) {
                currentUrl = LOCAL_URL;
                wsAddressInput.value = LOCAL_URL;
                toggleBtn.textContent = 'Switch to remote';
            } else {
                currentUrl = REMOTE_URL;
                wsAddressInput.value = REMOTE_URL;
                toggleBtn.textContent = 'Switch to localhost';
            }
            ws = null;
            connectWebSocket(currentUrl);
        });

        // resetBtn.addEventListener('click', () => {

        //     if (ws && confirm("Are you sure you want to reset SystemStatus?")) {
        //         ws.send("system_status_reset");
        //     }
        // })
        // Connect initially to remote server

        connectBtn.addEventListener('click', () => {
            const url = wsAddressInput.value.trim();
            if (!url) {
                alert('Please enter a WebSocket URL.');
                return;
            }
            connectWebSocket(url);
        });

        clearLogBtn.addEventListener('click', () => {clearPre(logPre, logQueue)});
        clearMqttBtn.addEventListener('click', () => {clearPre(mqttPre, mqttQueue)});
        clearStatusBtn.addEventListener('click', () => {clearPre(statusPre, statusQueue)});

        connectWebSocket(wsAddressInput.value);
    </script>
</body>
</html>
